shader_type spatial;
render_mode blend_add, cull_back, depth_draw_always;
uniform sampler2D face_text: source_color, repeat_disable;
uniform sampler2D noise;
uniform sampler2D noise2;
uniform vec3 head_color = vec3(0.6, 0., 0.4);
uniform vec3 face_color = vec3(0., 0., 0.);
uniform vec3 uv1_scale;
uniform vec3 uv1_offset;
uniform vec4 emission_color: source_color;
uniform float emission_amount: hint_range(0.0, 16.0) = 5.0;
uniform float rim_sharpness: hint_range(0.0, 16.0) = 3.0;

uniform float red: hint_range(0.,1.) = 0.;

void vertex() {
	// Called for every vertex the material is visible on.
	UV=UV*uv1_scale.xy+uv1_offset.xy;
	VERTEX.y += sin(TIME * 1. + VERTEX.x * 3.) * 0.05;
	VERTEX.x += cos(TIME * 1. + VERTEX.y * 3.) * 0.05;
}

void fragment() {
	// Called for every pixel the material is visible on.
	vec2 uv = UV;
	vec2 move_uv = vec2(.2, .0) * TIME;
	vec3 wave_color = vec3(1., 0.6, 0.4);
	vec3 tex_color = texture(face_text, uv).rgb;
	vec3 out_color = tex_color.r * head_color + tex_color.g * wave_color;
	out_color.r += clamp(out_color.r + red, 0., 1.);
	out_color.g = clamp(out_color.g - red, 0., 1.);
	out_color.b = clamp(out_color.b - red, 0., 1.);
	vec3 noise_n = texture(noise, sin(uv + move_uv) * 5.).rgb;
	vec3 noise_m = texture(noise, sin(uv - move_uv) * 5.).rgb;
	ALBEDO = out_color * noise_n * noise_m;
	EMISSION = emission_color.rgb * emission_amount - red;
	ALPHA = clamp(cos(pow(1.0 - dot(NORMAL, VIEW), rim_sharpness) * emission_color.a) + red, 0., 1.);
	//ALBEDO = vec3(1.,0.,0.);
}

//void light() {
	// Called for every pixel for every light affecting the material.
	// Uncomment to replace the default light processing function with this one.
//}
